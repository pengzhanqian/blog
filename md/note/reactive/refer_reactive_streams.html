<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.23" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.93" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Reactive Streams","image":[""],"dateModified":"2025-07-04T06:08:40.000Z","author":[{"@type":"Person","name":"钱鹏展","url":"https://github.com/pengzhanqian"}]}</script><meta property="og:url" content="https://pengzhanqian.github.io/blog/md/note/reactive/refer_reactive_streams.html"><meta property="og:site_name" content="学习笔记"><meta property="og:title" content="Reactive Streams"><meta property="og:description" content="Reactive Streams The purpose of Reactive Streams is to provide a standard for asynchronous stream processing with non-blocking backpressure. The latest release is available on M..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2025-07-04T06:08:40.000Z"><meta property="article:modified_time" content="2025-07-04T06:08:40.000Z"><meta name="application-name" content="学习笔记"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#46bd87"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/blog/favicon.ico"><link rel="manifest" href="/blog/manifest.webmanifest" crossorigin="use-credentials"><link rel="icon" href="/blog/assets/icon/chrome-mask-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/blog/assets/icon/chrome-mask-192.png" type="image/png" sizes="192x192"><link rel="icon" href="/blog/assets/icon/chrome-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/blog/assets/icon/chrome-192.png" type="image/png" sizes="192x192"><link rel="apple-touch-icon" href="/blog/assets/icon/apple-icon-152.png"><title>Reactive Streams | 学习笔记</title><meta name="description" content="Reactive Streams The purpose of Reactive Streams is to provide a standard for asynchronous stream processing with non-blocking backpressure. The latest release is available on M...">
    <link rel="preload" href="/blog/assets/style-CkPCWbCO.css" as="style"><link rel="stylesheet" href="/blog/assets/style-CkPCWbCO.css">
    <link rel="modulepreload" href="/blog/assets/app-BxRTHQDl.js"><link rel="modulepreload" href="/blog/assets/refer_reactive_streams.html-D6oSWrJ_.js"><link rel="modulepreload" href="/blog/assets/plugin-vue_export-helper-DlAUqK2U.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/blog/" aria-label="带我回家"><img class="vp-nav-logo" src="/blog/logo.gif" alt><!----><span class="vp-site-name hide-in-pad">学习笔记</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/blog/" aria-label="首页"><!---->首页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/blog/md/interview/" aria-label="面试"><!---->面试<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/blog/md/algorithm/" aria-label="算法"><!---->算法<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="学习笔记"><!--[--><!---->学习笔记<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">学习笔记 - JAVA</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/note/java/first/first_001.html" aria-label="初识JAVA"><!---->初识JAVA<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/note/java/basic/basic_001.html" aria-label="JAVA基础知识"><!---->JAVA基础知识<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/note/java/jvm/jvm_001.html" aria-label="深入理解JVM"><!---->深入理解JVM<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/note/java/detail/detail_001.html" aria-label="JAVA代码细节"><!---->JAVA代码细节<!----></a></li></ul></li><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">学习笔记 - GO</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/note/go/basic/golang_001.html" aria-label="GoLang 基础"><!---->GoLang 基础<!----></a></li></ul></li><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">学习笔记 - 响应式编程</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/note/reactive/reactive_001.html" aria-label="第一章: 走进响应式编程"><!---->第一章: 走进响应式编程<!----></a></li></ul></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="常见问题"><!--[--><!---->常见问题<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/md/question/idea/question_idea_001.html" aria-label="intellj idea BUG"><!---->intellj idea BUG<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/md/question/net/question_net_001.html" aria-label="网络相关知识"><!---->网络相关知识<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="更多"><!--[--><!---->更多<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/md/more/ali/ali_001.html" aria-label="阿里"><!---->阿里<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/md/more/essay/essay_001_linux_command.html" aria-label="随笔"><!---->随笔<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/md/more/real-operation/ro_001.html" aria-label="实操系列"><!---->实操系列<!----></a></li></ul></button></div></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/pengzhanqian/blog" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><a class="route-link route-link-active auto-link vp-sidebar-title no-external-link-icon" href="/blog/md/note/reactive/" aria-label="响应式编程"><!---->响应式编程<!----></a><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Reactive Streams</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/pengzhanqian" target="_blank" rel="noopener noreferrer">钱鹏展</a></span><span property="author" content="钱鹏展"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2025/7/3</span><meta property="datePublished" content="2025-07-03T13:31:56.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 17 分钟</span><meta property="timeRequired" content="PT17M"></span><!----><!----></div><hr></div><!----><div class="" vp-content><!----><div id="markdown-content"><h1 id="reactive-streams" tabindex="-1"><a class="header-anchor" href="#reactive-streams"><span>Reactive Streams</span></a></h1><p>The purpose of Reactive Streams is to provide a standard for asynchronous stream processing with non-blocking backpressure.</p><p>The latest release is available on Maven Central as</p><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-xml"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;org.reactivestreams&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;reactive-streams&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">version</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;1.0.4&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">version</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;org.reactivestreams&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;reactive-streams-tck&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">version</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;1.0.4&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">version</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">scope</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;test&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">scope</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="goals-design-and-scope" tabindex="-1"><a class="header-anchor" href="#goals-design-and-scope"><span>Goals, Design and Scope</span></a></h2><p>Handling streams of data—especially “live” data whose volume is not predetermined—requires special care in an asynchronous system. The most prominent issue is that resource consumption needs to be carefully controlled such that a fast data source does not overwhelm the stream destination. Asynchrony is needed in order to enable the parallel use of computing resources, on collaborating network hosts or multiple CPU cores within a single machine.</p><p>The main goal of Reactive Streams is to govern the exchange of stream data across an asynchronous boundary – think passing elements on to another thread or thread-pool — while ensuring that the receiving side is not forced to buffer arbitrary amounts of data. In other words, backpressure is an integral part of this model in order to allow the queues which mediate between threads to be bounded. The benefits of asynchronous processing would be negated if the backpressure signals were synchronous (see also the <a href="http://reactivemanifesto.org/" target="_blank" rel="noopener noreferrer">Reactive Manifesto</a>), therefore care has been taken to mandate fully non-blocking and asynchronous behavior of all aspects of a Reactive Streams implementation.</p><p>It is the intention of this specification to allow the creation of many conforming implementations, which by virtue of abiding by the rules will be able to interoperate smoothly, preserving the aforementioned benefits and characteristics across the whole processing graph of a stream application.</p><p>It should be noted that the precise nature of stream manipulations (transformation, splitting, merging, etc.) is not covered by this specification. Reactive Streams are only concerned with mediating the stream of data between different <a href="#api-components">API Components</a>. In their development care has been taken to ensure that all basic ways of combining streams can be expressed.</p><p>In summary, Reactive Streams is a standard and specification for Stream-oriented libraries for the JVM that</p><ul><li>process a potentially unbounded number of elements</li><li>in sequence,</li><li>asynchronously passing elements between components,</li><li>with mandatory non-blocking backpressure.</li></ul><p>The Reactive Streams specification consists of the following parts:</p><p><em><strong>The API</strong></em> specifies the types to implement Reactive Streams and achieve interoperability between different implementations.</p><p><em><strong>The Technology Compatibility Kit (TCK)</strong></em> is a standard test suite for conformance testing of implementations.</p><p>Implementations are free to implement additional features not covered by the specification as long as they conform to the API requirements and pass the tests in the TCK.</p><h3 id="api-components" tabindex="-1"><a class="header-anchor" href="#api-components"><span>API Components</span></a></h3><p>The API consists of the following components that are required to be provided by Reactive Stream implementations:</p><ol><li>Publisher</li><li>Subscriber</li><li>Subscription</li><li>Processor</li></ol><p>A <em>Publisher</em> is a provider of a potentially unbounded number of sequenced elements, publishing them according to the demand received from its Subscriber(s).</p><p>In response to a call to <code>Publisher.subscribe(Subscriber)</code> the possible invocation sequences for methods on the <code>Subscriber</code> are given by the following protocol:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>onSubscribe onNext* (onError | onComplete)?</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>This means that <code>onSubscribe</code> is always signalled,<br> followed by a possibly unbounded number of <code>onNext</code> signals (as requested by <code>Subscriber</code>) followed by an <code>onError</code> signal if there is a failure, or an <code>onComplete</code> signal when no more elements are available—all as long as the <code>Subscription</code> is not cancelled.</p><h4 id="notes" tabindex="-1"><a class="header-anchor" href="#notes"><span>NOTES</span></a></h4><ul><li>The specifications below use binding words in capital letters from <a href="https://www.ietf.org/rfc/rfc2119.txt" target="_blank" rel="noopener noreferrer">https://www.ietf.org/rfc/rfc2119.txt</a></li></ul><h3 id="glossary" tabindex="-1"><a class="header-anchor" href="#glossary"><span>Glossary</span></a></h3><table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td><a name="term_signal">Signal</a></td><td>As a noun: one of the <code>onSubscribe</code>, <code>onNext</code>, <code>onComplete</code>, <code>onError</code>, <code>request(n)</code> or <code>cancel</code> methods. As a verb: calling/invoking a signal.</td></tr><tr><td><a name="term_demand">Demand</a></td><td>As a noun, the aggregated number of elements requested by a Subscriber which is yet to be delivered (fulfilled) by the Publisher. As a verb, the act of <code>request</code>-ing more elements.</td></tr><tr><td><a name="term_sync">Synchronous(ly)</a></td><td>Executes on the calling Thread.</td></tr><tr><td><a name="term_return_normally">Return normally</a></td><td>Only ever returns a value of the declared type to the caller. The only legal way to signal failure to a <code>Subscriber</code> is via the <code>onError</code> method.</td></tr><tr><td><a name="term_responsivity">Responsivity</a></td><td>Readiness/ability to respond. In this document used to indicate that the different components should not impair each others ability to respond.</td></tr><tr><td><a name="term_non-obstructing">Non-obstructing</a></td><td>Quality describing a method which is as quick to execute as possible—on the calling thread. This means, for example, avoids heavy computations and other things that would stall the caller´s thread of execution.</td></tr><tr><td><a name="term_terminal_state">Terminal state</a></td><td>For a Publisher: When <code>onComplete</code> or <code>onError</code> has been signalled. For a Subscriber: When an <code>onComplete</code> or <code>onError</code> has been received.</td></tr><tr><td><a name="term_nop">NOP</a></td><td>Execution that has no detectable effect to the calling thread, and can as such safely be called any number of times.</td></tr><tr><td><a name="term_serially">Serial(ly)</a></td><td>In the context of a <a href="#term_signal">Signal</a>, non-overlapping. In the context of the JVM, calls to methods on an object are serial if and only if there is a happens-before relationship between those calls (implying also that the calls do not overlap). When the calls are performed asynchronously, coordination to establish the happens-before relationship is to be implemented using techniques such as, but not limited to, atomics, monitors, or locks.</td></tr><tr><td><a name="term_thread-safe">Thread-safe</a></td><td>Can be safely invoked synchronously, or asychronously, without requiring external synchronization to ensure program correctness.</td></tr></tbody></table><h3 id="specification" tabindex="-1"><a class="header-anchor" href="#specification"><span>SPECIFICATION</span></a></h3><h4 id="_1-publisher-code" tabindex="-1"><a class="header-anchor" href="#_1-publisher-code"><span>1. Publisher (<a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.4/api/src/main/java/org/reactivestreams/Publisher.java" target="_blank" rel="noopener noreferrer">Code</a>)</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Publisher</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> subscribe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Subscriber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> super</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>ID</th><th>Rule</th></tr></thead><tbody><tr><td><a name="1.1">1</a></td><td>The total number of <code>onNext</code>´s signalled by a <code>Publisher</code> to a <code>Subscriber</code> MUST be less than or equal to the total number of elements requested by that <code>Subscriber</code>´s <code>Subscription</code> at all times.</td></tr><tr><td><a href="#1.1" title="1.1 explained">💡</a></td><td><em>The intent of this rule is to make it clear that Publishers cannot signal more elements than Subscribers have requested. There’s an implicit, but important, consequence to this rule: Since demand can only be fulfilled after it has been received, there’s a happens-before relationship between requesting elements and receiving elements.</em></td></tr><tr><td><a name="1.2">2</a></td><td>A <code>Publisher</code> MAY signal fewer <code>onNext</code> than requested and terminate the <code>Subscription</code> by calling <code>onComplete</code> or <code>onError</code>.</td></tr><tr><td><a href="#1.2" title="1.2 explained">💡</a></td><td><em>The intent of this rule is to make it clear that a Publisher cannot guarantee that it will be able to produce the number of elements requested; it simply might not be able to produce them all; it may be in a failed state; it may be empty or otherwise already completed.</em></td></tr><tr><td><a name="1.3">3</a></td><td><code>onSubscribe</code>, <code>onNext</code>, <code>onError</code> and <code>onComplete</code> signaled to a <code>Subscriber</code> MUST be signaled <a href="#term_serially">serially</a>.</td></tr><tr><td><a href="#1.3" title="1.3 explained">💡</a></td><td><em>The intent of this rule is to permit the signalling of signals (including from multiple threads) if and only if a happens-before relation between each of the signals is established.</em></td></tr><tr><td><a name="1.4">4</a></td><td>If a <code>Publisher</code> fails it MUST signal an <code>onError</code>.</td></tr><tr><td><a href="#1.4" title="1.4 explained">💡</a></td><td><em>The intent of this rule is to make it clear that a Publisher is responsible for notifying its Subscribers if it detects that it cannot proceed—Subscribers must be given a chance to clean up resources or otherwise deal with the Publisher´s failures.</em></td></tr><tr><td><a name="1.5">5</a></td><td>If a <code>Publisher</code> terminates successfully (finite stream) it MUST signal an <code>onComplete</code>.</td></tr><tr><td><a href="#1.5" title="1.5 explained">💡</a></td><td><em>The intent of this rule is to make it clear that a Publisher is responsible for notifying its Subscribers that it has reached a <a href="#term_terminal_state">terminal state</a>—Subscribers can then act on this information; clean up resources, etc.</em></td></tr><tr><td><a name="1.6">6</a></td><td>If a <code>Publisher</code> signals either <code>onError</code> or <code>onComplete</code> on a <code>Subscriber</code>, that <code>Subscriber</code>’s <code>Subscription</code> MUST be considered cancelled.</td></tr><tr><td><a href="#1.6" title="1.6 explained">💡</a></td><td><em>The intent of this rule is to make sure that a Subscription is treated the same no matter if it was cancelled, the Publisher signalled onError or onComplete.</em></td></tr><tr><td><a name="1.7">7</a></td><td>Once a <a href="#term_terminal_state">terminal state</a> has been signaled (<code>onError</code>, <code>onComplete</code>) it is REQUIRED that no further signals occur.</td></tr><tr><td><a href="#1.7" title="1.7 explained">💡</a></td><td><em>The intent of this rule is to make sure that onError and onComplete are the final states of an interaction between a Publisher and Subscriber pair.</em></td></tr><tr><td><a name="1.8">8</a></td><td>If a <code>Subscription</code> is cancelled its <code>Subscriber</code> MUST eventually stop being signaled.</td></tr><tr><td><a href="#1.8" title="1.8 explained">💡</a></td><td><em>The intent of this rule is to make sure that Publishers respect a Subscriber’s request to cancel a Subscription when Subscription.cancel() has been called. The reason for <strong>eventually</strong> is because signals can have propagation delay due to being asynchronous.</em></td></tr><tr><td><a name="1.9">9</a></td><td><code>Publisher.subscribe</code> MUST call <code>onSubscribe</code> on the provided <code>Subscriber</code> prior to any other signals to that <code>Subscriber</code> and MUST <a href="#term_return_normally">return normally</a>, except when the provided <code>Subscriber</code> is <code>null</code> in which case it MUST throw a <code>java.lang.NullPointerException</code> to the caller, for all other situations the only legal way to signal failure (or reject the <code>Subscriber</code>) is by calling <code>onError</code> (after calling <code>onSubscribe</code>).</td></tr><tr><td><a href="#1.9" title="1.9 explained">💡</a></td><td><em>The intent of this rule is to make sure that <code>onSubscribe</code> is always signalled before any of the other signals, so that initialization logic can be executed by the Subscriber when the signal is received. Also <code>onSubscribe</code> MUST only be called at most once, [see <a href="#2.12">2.12</a>]. If the supplied <code>Subscriber</code> is <code>null</code>, there is nowhere else to signal this but to the caller, which means a <code>java.lang.NullPointerException</code> must be thrown. Examples of possible situations: A stateful Publisher can be overwhelmed, bounded by a finite number of underlying resources, exhausted, or in a <a href="#term_terminal_state">terminal state</a>.</em></td></tr><tr><td><a name="1.10">10</a></td><td><code>Publisher.subscribe</code> MAY be called as many times as wanted but MUST be with a different <code>Subscriber</code> each time [see <a href="#2.12">2.12</a>].</td></tr><tr><td><a href="#1.10" title="1.10 explained">💡</a></td><td><em>The intent of this rule is to have callers of <code>subscribe</code> be aware that a generic Publisher and a generic Subscriber cannot be assumed to support being attached multiple times. Furthermore, it also mandates that the semantics of <code>subscribe</code> must be upheld no matter how many times it is called.</em></td></tr><tr><td><a name="1.11">11</a></td><td>A <code>Publisher</code> MAY support multiple <code>Subscriber</code>s and decides whether each <code>Subscription</code> is unicast or multicast.</td></tr><tr><td><a href="#1.11" title="1.11 explained">💡</a></td><td><em>The intent of this rule is to give Publisher implementations the flexibility to decide how many, if any, Subscribers they will support, and how elements are going to be distributed.</em></td></tr></tbody></table><h4 id="_2-subscriber-code" tabindex="-1"><a class="header-anchor" href="#_2-subscriber-code"><span>2. Subscriber (<a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.4/api/src/main/java/org/reactivestreams/Subscriber.java" target="_blank" rel="noopener noreferrer">Code</a>)</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Subscriber</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> onSubscribe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Subscription</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> onNext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> onError</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Throwable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> onComplete</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>ID</th><th>Rule</th></tr></thead><tbody><tr><td><a name="2.1">1</a></td><td>A <code>Subscriber</code> MUST signal demand via <code>Subscription.request(long n)</code> to receive <code>onNext</code> signals.</td></tr><tr><td><a href="#2.1" title="2.1 explained">💡</a></td><td><em>The intent of this rule is to establish that it is the responsibility of the Subscriber to decide when and how many elements it is able and willing to receive. To avoid signal reordering caused by reentrant Subscription methods, it is strongly RECOMMENDED for synchronous Subscriber implementations to invoke Subscription methods at the very end of any signal processing. It is RECOMMENDED that Subscribers request the upper limit of what they are able to process, as requesting only one element at a time results in an inherently inefficient &quot;stop-and-wait&quot; protocol.</em></td></tr><tr><td><a name="2.2">2</a></td><td>If a <code>Subscriber</code> suspects that its processing of signals will negatively impact its <code>Publisher</code>´s responsivity, it is RECOMMENDED that it asynchronously dispatches its signals.</td></tr><tr><td><a href="#2.2" title="2.2 explained">💡</a></td><td><em>The intent of this rule is that a Subscriber should <a href="#term_non-obstructing">not obstruct</a> the progress of the Publisher from an execution point-of-view. In other words, the Subscriber should not starve the Publisher from receiving CPU cycles.</em></td></tr><tr><td><a name="2.3">3</a></td><td><code>Subscriber.onComplete()</code> and <code>Subscriber.onError(Throwable t)</code> MUST NOT call any methods on the <code>Subscription</code> or the <code>Publisher</code>.</td></tr><tr><td><a href="#2.3" title="2.3 explained">💡</a></td><td><em>The intent of this rule is to prevent cycles and race-conditions—between Publisher, Subscription and Subscriber—during the processing of completion signals.</em></td></tr><tr><td><a name="2.4">4</a></td><td><code>Subscriber.onComplete()</code> and <code>Subscriber.onError(Throwable t)</code> MUST consider the Subscription cancelled after having received the signal.</td></tr><tr><td><a href="#2.4" title="2.4 explained">💡</a></td><td><em>The intent of this rule is to make sure that Subscribers respect a Publisher’s <a href="#term_terminal_state">terminal state</a> signals. A Subscription is simply not valid anymore after an onComplete or onError signal has been received.</em></td></tr><tr><td><a name="2.5">5</a></td><td>A <code>Subscriber</code> MUST call <code>Subscription.cancel()</code> on the given <code>Subscription</code> after an <code>onSubscribe</code> signal if it already has an active <code>Subscription</code>.</td></tr><tr><td><a href="#2.5" title="2.5 explained">💡</a></td><td><em>The intent of this rule is to prevent that two, or more, separate Publishers from trying to interact with the same Subscriber. Enforcing this rule means that resource leaks are prevented since extra Subscriptions will be cancelled. Failure to conform to this rule may lead to violations of Publisher rule 1, amongst others. Such violations can lead to hard-to-diagnose bugs.</em></td></tr><tr><td><a name="2.6">6</a></td><td>A <code>Subscriber</code> MUST call <code>Subscription.cancel()</code> if the <code>Subscription</code> is no longer needed.</td></tr><tr><td><a href="#2.6" title="2.6 explained">💡</a></td><td><em>The intent of this rule is to establish that Subscribers cannot just throw Subscriptions away when they are no longer needed, they have to call <code>cancel</code> so that resources held by that Subscription can be safely, and timely, reclaimed. An example of this would be a Subscriber which is only interested in a specific element, which would then cancel its Subscription to signal its completion to the Publisher.</em></td></tr><tr><td><a name="2.7">7</a></td><td>A Subscriber MUST ensure that all calls on its Subscription&#39;s request and cancel methods are performed <a href="#term_serially">serially</a>.</td></tr><tr><td><a href="#2.7" title="2.7 explained">💡</a></td><td><em>The intent of this rule is to permit the calling of the request and cancel methods (including from multiple threads) if and only if a <a href="#term_serially">serial</a> relation between each of the calls is established.</em></td></tr><tr><td><a name="2.8">8</a></td><td>A <code>Subscriber</code> MUST be prepared to receive one or more <code>onNext</code> signals after having called <code>Subscription.cancel()</code> if there are still requested elements pending [see <a href="#3.12">3.12</a>]. <code>Subscription.cancel()</code> does not guarantee to perform the underlying cleaning operations immediately.</td></tr><tr><td><a href="#2.8" title="2.8 explained">💡</a></td><td><em>The intent of this rule is to highlight that there may be a delay between calling <code>cancel</code> and the Publisher observing that cancellation.</em></td></tr><tr><td><a name="2.9">9</a></td><td>A <code>Subscriber</code> MUST be prepared to receive an <code>onComplete</code> signal with or without a preceding <code>Subscription.request(long n)</code> call.</td></tr><tr><td><a href="#2.9" title="2.9 explained">💡</a></td><td><em>The intent of this rule is to establish that completion is unrelated to the demand flow—this allows for streams which complete early, and obviates the need to <em>poll</em> for completion.</em></td></tr><tr><td><a name="2.10">10</a></td><td>A <code>Subscriber</code> MUST be prepared to receive an <code>onError</code> signal with or without a preceding <code>Subscription.request(long n)</code> call.</td></tr><tr><td><a href="#2.10" title="2.10 explained">💡</a></td><td><em>The intent of this rule is to establish that Publisher failures may be completely unrelated to signalled demand. This means that Subscribers do not need to poll to find out if the Publisher will not be able to fulfill its requests.</em></td></tr><tr><td><a name="2.11">11</a></td><td>A <code>Subscriber</code> MUST make sure that all calls on its <a href="#term_signal">signal</a> methods happen-before the processing of the respective signals. I.e. the Subscriber must take care of properly publishing the signal to its processing logic.</td></tr><tr><td><a href="#2.11" title="2.11 explained">💡</a></td><td><em>The intent of this rule is to establish that it is the responsibility of the Subscriber implementation to make sure that asynchronous processing of its signals are thread safe. See <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5" target="_blank" rel="noopener noreferrer">JMM definition of Happens-Before in section 17.4.5</a>.</em></td></tr><tr><td><a name="2.12">12</a></td><td><code>Subscriber.onSubscribe</code> MUST be called at most once for a given <code>Subscriber</code> (based on object equality).</td></tr><tr><td><a href="#2.12" title="2.12 explained">💡</a></td><td><em>The intent of this rule is to establish that it MUST be assumed that the same Subscriber can only be subscribed at most once. Note that <code>object equality</code> is <code>a.equals(b)</code>.</em></td></tr><tr><td><a name="2.13">13</a></td><td>Calling <code>onSubscribe</code>, <code>onNext</code>, <code>onError</code> or <code>onComplete</code> MUST <a href="#term_return_normally">return normally</a> except when any provided parameter is <code>null</code> in which case it MUST throw a <code>java.lang.NullPointerException</code> to the caller, for all other situations the only legal way for a <code>Subscriber</code> to signal failure is by cancelling its <code>Subscription</code>. In the case that this rule is violated, any associated <code>Subscription</code> to the <code>Subscriber</code> MUST be considered as cancelled, and the caller MUST raise this error condition in a fashion that is adequate for the runtime environment.</td></tr><tr><td><a href="#2.13" title="2.13 explained">💡</a></td><td><em>The intent of this rule is to establish the semantics for the methods of Subscriber and what the Publisher is allowed to do in which case this rule is violated. «Raise this error condition in a fashion that is adequate for the runtime environment» could mean logging the error—or otherwise make someone or something aware of the situation—as the error cannot be signalled to the faulty Subscriber.</em></td></tr></tbody></table><h4 id="_3-subscription-code" tabindex="-1"><a class="header-anchor" href="#_3-subscription-code"><span>3. Subscription (<a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.4/api/src/main/java/org/reactivestreams/Subscription.java" target="_blank" rel="noopener noreferrer">Code</a>)</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Subscription</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> request</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> cancel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>ID</th><th>Rule</th></tr></thead><tbody><tr><td><a name="3.1">1</a></td><td><code>Subscription.request</code> and <code>Subscription.cancel</code> MUST only be called inside of its <code>Subscriber</code> context.</td></tr><tr><td><a href="#3.1" title="3.1 explained">💡</a></td><td><em>The intent of this rule is to establish that a Subscription represents the unique relationship between a Subscriber and a Publisher [see <a href="#2.12">2.12</a>]. The Subscriber is in control over when elements are requested and when more elements are no longer needed.</em></td></tr><tr><td><a name="3.2">2</a></td><td>The <code>Subscription</code> MUST allow the <code>Subscriber</code> to call <code>Subscription.request</code> synchronously from within <code>onNext</code> or <code>onSubscribe</code>.</td></tr><tr><td><a href="#3.2" title="3.2 explained">💡</a></td><td><em>The intent of this rule is to make it clear that implementations of <code>request</code> must be reentrant, to avoid stack overflows in the case of mutual recursion between <code>request</code> and <code>onNext</code> (and eventually <code>onComplete</code> / <code>onError</code>). This implies that Publishers can be <code>synchronous</code>, i.e. signalling <code>onNext</code>´s on the thread which calls <code>request</code>.</em></td></tr><tr><td><a name="3.3">3</a></td><td><code>Subscription.request</code> MUST place an upper bound on possible synchronous recursion between <code>Publisher</code> and <code>Subscriber</code>.</td></tr><tr><td><a href="#3.3" title="3.3 explained">💡</a></td><td><em>The intent of this rule is to complement [see <a href="#3.2">3.2</a>] by placing an upper limit on the mutual recursion between <code>request</code> and <code>onNext</code> (and eventually <code>onComplete</code> / <code>onError</code>). Implementations are RECOMMENDED to limit this mutual recursion to a depth of <code>1</code> (ONE)—for the sake of conserving stack space. An example for undesirable synchronous, open recursion would be Subscriber.onNext -&gt; Subscription.request -&gt; Subscriber.onNext -&gt; …, as it otherwise will result in blowing the calling thread´s stack.</em></td></tr><tr><td><a name="3.4">4</a></td><td><code>Subscription.request</code> SHOULD respect the responsivity of its caller by returning in a timely manner.</td></tr><tr><td><a href="#3.4" title="3.4 explained">💡</a></td><td><em>The intent of this rule is to establish that <code>request</code> is intended to be a <a href="#term_non-obstructing">non-obstructing</a> method, and should be as quick to execute as possible on the calling thread, so avoid heavy computations and other things that would stall the caller´s thread of execution.</em></td></tr><tr><td><a name="3.5">5</a></td><td><code>Subscription.cancel</code> MUST respect the responsivity of its caller by returning in a timely manner, MUST be idempotent and MUST be <a href="#term_thread-safe">thread-safe</a>.</td></tr><tr><td><a href="#3.5" title="3.5 explained">💡</a></td><td><em>The intent of this rule is to establish that <code>cancel</code> is intended to be a <a href="#term_non-obstructing">non-obstructing</a> method, and should be as quick to execute as possible on the calling thread, so avoid heavy computations and other things that would stall the caller´s thread of execution. Furthermore, it is also important that it is possible to call it multiple times without any adverse effects.</em></td></tr><tr><td><a name="3.6">6</a></td><td>After the <code>Subscription</code> is cancelled, additional <code>Subscription.request(long n)</code> MUST be <a href="#term_nop">NOPs</a>.</td></tr><tr><td><a href="#3.6" title="3.6 explained">💡</a></td><td><em>The intent of this rule is to establish a causal relationship between cancellation of a subscription and the subsequent non-operation of requesting more elements.</em></td></tr><tr><td><a name="3.7">7</a></td><td>After the <code>Subscription</code> is cancelled, additional <code>Subscription.cancel()</code> MUST be <a href="#term_nop">NOPs</a>.</td></tr><tr><td><a href="#3.7" title="3.7 explained">💡</a></td><td><em>The intent of this rule is superseded by <a href="#3.5">3.5</a>.</em></td></tr><tr><td><a name="3.8">8</a></td><td>While the <code>Subscription</code> is not cancelled, <code>Subscription.request(long n)</code> MUST register the given number of additional elements to be produced to the respective subscriber.</td></tr><tr><td><a href="#3.8" title="3.8 explained">💡</a></td><td><em>The intent of this rule is to make sure that <code>request</code>-ing is an additive operation, as well as ensuring that a request for elements is delivered to the Publisher.</em></td></tr><tr><td><a name="3.9">9</a></td><td>While the <code>Subscription</code> is not cancelled, <code>Subscription.request(long n)</code> MUST signal <code>onError</code> with a <code>java.lang.IllegalArgumentException</code> if the argument is &lt;= 0. The cause message SHOULD explain that non-positive request signals are illegal.</td></tr><tr><td><a href="#3.9" title="3.9 explained">💡</a></td><td><em>The intent of this rule is to prevent faulty implementations to proceed operation without any exceptions being raised. Requesting a negative or 0 number of elements, since requests are additive, most likely to be the result of an erroneous calculation on the behalf of the Subscriber.</em></td></tr><tr><td><a name="3.10">10</a></td><td>While the <code>Subscription</code> is not cancelled, <code>Subscription.request(long n)</code> MAY synchronously call <code>onNext</code> on this (or other) subscriber(s).</td></tr><tr><td><a href="#3.10" title="3.10 explained">💡</a></td><td><em>The intent of this rule is to establish that it is allowed to create synchronous Publishers, i.e. Publishers who execute their logic on the calling thread.</em></td></tr><tr><td><a name="3.11">11</a></td><td>While the <code>Subscription</code> is not cancelled, <code>Subscription.request(long n)</code> MAY synchronously call <code>onComplete</code> or <code>onError</code> on this (or other) subscriber(s).</td></tr><tr><td><a href="#3.11" title="3.11 explained">💡</a></td><td><em>The intent of this rule is to establish that it is allowed to create synchronous Publishers, i.e. Publishers who execute their logic on the calling thread.</em></td></tr><tr><td><a name="3.12">12</a></td><td>While the <code>Subscription</code> is not cancelled, <code>Subscription.cancel()</code> MUST request the <code>Publisher</code> to eventually stop signaling its <code>Subscriber</code>. The operation is NOT REQUIRED to affect the <code>Subscription</code> immediately.</td></tr><tr><td><a href="#3.12" title="3.12 explained">💡</a></td><td><em>The intent of this rule is to establish that the desire to cancel a Subscription is eventually respected by the Publisher, acknowledging that it may take some time before the signal is received.</em></td></tr><tr><td><a name="3.13">13</a></td><td>While the <code>Subscription</code> is not cancelled, <code>Subscription.cancel()</code> MUST request the <code>Publisher</code> to eventually drop any references to the corresponding subscriber.</td></tr><tr><td><a href="#3.13" title="3.13 explained">💡</a></td><td><em>The intent of this rule is to make sure that Subscribers can be properly garbage-collected after their subscription no longer being valid. Re-subscribing with the same Subscriber object is discouraged [see <a href="#2.12">2.12</a>], but this specification does not mandate that it is disallowed since that would mean having to store previously cancelled subscriptions indefinitely.</em></td></tr><tr><td><a name="3.14">14</a></td><td>While the <code>Subscription</code> is not cancelled, calling <code>Subscription.cancel</code> MAY cause the <code>Publisher</code>, if stateful, to transition into the <code>shut-down</code> state if no other <code>Subscription</code> exists at this point [see <a href="#1.9">1.9</a>].</td></tr><tr><td><a href="#3.14" title="3.14 explained">💡</a></td><td><em>The intent of this rule is to allow for Publishers to signal <code>onComplete</code> or <code>onError</code> following <code>onSubscribe</code> for new Subscribers in response to a cancellation signal from an existing Subscriber.</em></td></tr><tr><td><a name="3.15">15</a></td><td>Calling <code>Subscription.cancel</code> MUST <a href="#term_return_normally">return normally</a>.</td></tr><tr><td><a href="#3.15" title="3.15 explained">💡</a></td><td><em>The intent of this rule is to disallow implementations to throw exceptions in response to <code>cancel</code> being called.</em></td></tr><tr><td><a name="3.16">16</a></td><td>Calling <code>Subscription.request</code> MUST <a href="#term_return_normally">return normally</a>.</td></tr><tr><td><a href="#3.16" title="3.16 explained">💡</a></td><td><em>The intent of this rule is to disallow implementations to throw exceptions in response to <code>request</code> being called.</em></td></tr><tr><td><a name="3.17">17</a></td><td>A <code>Subscription</code> MUST support an unbounded number of calls to <code>request</code> and MUST support a demand up to 2^63-1 (<code>java.lang.Long.MAX_VALUE</code>). A demand equal or greater than 2^63-1 (<code>java.lang.Long.MAX_VALUE</code>) MAY be considered by the <code>Publisher</code> as “effectively unbounded”.</td></tr><tr><td><a href="#3.17" title="3.17 explained">💡</a></td><td><em>The intent of this rule is to establish that the Subscriber can request an unbounded number of elements, in any increment above 0 [see <a href="#3.9">3.9</a>], in any number of invocations of <code>request</code>. As it is not feasibly reachable with current or foreseen hardware within a reasonable amount of time (1 element per nanosecond would take 292 years) to fulfill a demand of 2^63-1, it is allowed for a Publisher to stop tracking demand beyond this point.</em></td></tr></tbody></table><p>A <code>Subscription</code> is shared by exactly one <code>Publisher</code> and one <code>Subscriber</code> for the purpose of mediating the data exchange between this pair. This is the reason why the <code>subscribe()</code> method does not return the created <code>Subscription</code>, but instead returns <code>void</code>; the <code>Subscription</code> is only passed to the <code>Subscriber</code> via the <code>onSubscribe</code> callback.</p><h4 id="_4-processor-code" tabindex="-1"><a class="header-anchor" href="#_4-processor-code"><span>4.Processor (<a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.4/api/src/main/java/org/reactivestreams/Processor.java" target="_blank" rel="noopener noreferrer">Code</a>)</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Processor</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> R</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Subscriber</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Publisher</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">R</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>ID</th><th>Rule</th></tr></thead><tbody><tr><td><a name="4.1">1</a></td><td>A <code>Processor</code> represents a processing stage—which is both a <code>Subscriber</code> and a <code>Publisher</code> and MUST obey the contracts of both.</td></tr><tr><td><a href="#4.1" title="4.1 explained">💡</a></td><td><em>The intent of this rule is to establish that Processors behave, and are bound by, both the Publisher and Subscriber specifications.</em></td></tr><tr><td><a name="4.2">2</a></td><td>A <code>Processor</code> MAY choose to recover an <code>onError</code> signal. If it chooses to do so, it MUST consider the <code>Subscription</code> cancelled, otherwise it MUST propagate the <code>onError</code> signal to its Subscribers immediately.</td></tr><tr><td><a href="#4.2" title="4.2 explained">💡</a></td><td><em>The intent of this rule is to inform that it’s possible for implementations to be more than simple transformations.</em></td></tr></tbody></table><p>While not mandated, it can be a good idea to cancel a <code>Processor</code>´s upstream <code>Subscription</code> when/if its last <code>Subscriber</code> cancels their <code>Subscription</code>,<br> to let the cancellation signal propagate upstream.</p><h3 id="asynchronous-vs-synchronous-processing" tabindex="-1"><a class="header-anchor" href="#asynchronous-vs-synchronous-processing"><span>Asynchronous vs Synchronous Processing</span></a></h3><p>The Reactive Streams API prescribes that all processing of elements (<code>onNext</code>) or termination signals (<code>onError</code>, <code>onComplete</code>) MUST NOT <em>block</em> the <code>Publisher</code>. However, each of the <code>on*</code> handlers can process the events synchronously or asynchronously.</p><p>Take this example:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>nioSelectorThreadOrigin map(f) filter(p) consumeTo(toNioSelectorOutput)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>It has an async origin and an async destination. Let’s assume that both origin and destination are selector event loops. The <code>Subscription.request(n)</code> must be chained from the destination to the origin. This is now where each implementation can choose how to do this.</p><p>The following uses the pipe <code>|</code> character to signal async boundaries (queue and schedule) and <code>R#</code> to represent resources (possibly threads).</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>nioSelectorThreadOrigin | map(f) | filter(p) | consumeTo(toNioSelectorOutput)</span></span>
<span class="line"><span>-------------- R1 ----  | - R2 - | -- R3 --- | ---------- R4 ----------------</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>In this example each of the 3 consumers, <code>map</code>, <code>filter</code> and <code>consumeTo</code> asynchronously schedule the work. It could be on the same event loop (trampoline), separate threads, whatever.</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>nioSelectorThreadOrigin map(f) filter(p) | consumeTo(toNioSelectorOutput)</span></span>
<span class="line"><span>------------------- R1 ----------------- | ---------- R2 ----------------</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Here it is only the final step that asynchronously schedules, by adding work to the NioSelectorOutput event loop. The <code>map</code> and <code>filter</code> steps are synchronously performed on the origin thread.</p><p>Or another implementation could fuse the operations to the final consumer:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>nioSelectorThreadOrigin | map(f) filter(p) consumeTo(toNioSelectorOutput)</span></span>
<span class="line"><span>--------- R1 ---------- | ------------------ R2 -------------------------</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>All of these variants are &quot;asynchronous streams&quot;. They all have their place and each has different tradeoffs including performance and implementation complexity.</p><p>The Reactive Streams contract allows implementations the flexibility to manage resources and scheduling and mix asynchronous and synchronous processing within the bounds of a non-blocking, asynchronous, dynamic push-pull stream.</p><p>In order to allow fully asynchronous implementations of all participating API elements—<code>Publisher</code>/<code>Subscription</code>/<code>Subscriber</code>/<code>Processor</code>—all methods defined by these interfaces return <code>void</code>.</p><h3 id="subscriber-controlled-queue-bounds" tabindex="-1"><a class="header-anchor" href="#subscriber-controlled-queue-bounds"><span>Subscriber controlled queue bounds</span></a></h3><p>One of the underlying design principles is that all buffer sizes are to be bounded and these bounds must be <em>known</em> and <em>controlled</em> by the subscribers. These bounds are expressed in terms of <em>element count</em> (which in turn translates to the invocation count of onNext). Any implementation that aims to support infinite streams (especially high output rate streams) needs to enforce bounds all along the way to avoid out-of-memory errors and constrain resource usage in general.</p><p>Since back-pressure is mandatory the use of unbounded buffers can be avoided. In general, the only time when a queue might grow without bounds is when the publisher side maintains a higher rate than the subscriber for an extended period of time, but this scenario is handled by backpressure instead.</p><p>Queue bounds can be controlled by a subscriber signaling demand for the appropriate number of elements. At any point in time the subscriber knows:</p><ul><li>the total number of elements requested: <code>P</code></li><li>the number of elements that have been processed: <code>N</code></li></ul><p>Then the maximum number of elements that may arrive—until more demand is signaled to the Publisher—is <code>P - N</code>. In the case that the subscriber also knows the number of elements B in its input buffer then this bound can be refined to <code>P - B - N</code>.</p><p>These bounds must be respected by a publisher independent of whether the source it represents can be backpressured or not. In the case of sources whose production rate cannot be influenced—for example clock ticks or mouse movement—the publisher must choose to either buffer or drop elements to obey the imposed bounds.</p><p>Subscribers signaling a demand for one element after the reception of an element effectively implement a Stop-and-Wait protocol where the demand signal is equivalent to acknowledgement. By providing demand for multiple elements the cost of acknowledgement is amortized. It is worth noting that the subscriber is allowed to signal demand at any point in time, allowing it to avoid unnecessary delays between the publisher and the subscriber (i.e. keeping its input buffer filled without having to wait for full round-trips).</p><h2 id="legal" tabindex="-1"><a class="header-anchor" href="#legal"><span>Legal</span></a></h2><p>This project is a collaboration between engineers from Kaazing, Lightbend, Netflix, Pivotal, Red Hat, Twitter and many others. This project is licensed under MIT No Attribution (SPDX: MIT-0).</p></div><!----><!----><!----></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/pengzhanqian/blog/edit/main/docs/md/note/reactive/refer_reactive_streams.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">最近更新</span><time class="vp-meta-info" datetime="2025-07-04T06:08:40.000Z" data-allow-mismatch>2025/7/4 06:08</time></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 873373549@qq.com">钱鹏展</span><!--]--><!--]--></div></div></footer><!----><div id="comment" class="giscus-wrapper input-top vp-comment" vp-comment style="display:block;"><div style="display: flex;align-items: center;justify-content: center;height: 96px"><span style="--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; preserveAspectRatio=&#39;xMidYMid&#39; viewBox=&#39;25 25 50 50&#39;%3E%3CanimateTransform attributeName=&#39;transform&#39; type=&#39;rotate&#39; dur=&#39;2s&#39; keyTimes=&#39;0;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;360&#39;%3E%3C/animateTransform%3E%3Ccircle cx=&#39;50&#39; cy=&#39;50&#39; r=&#39;20&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39; stroke-width=&#39;4&#39; stroke-linecap=&#39;round&#39;%3E%3Canimate attributeName=&#39;stroke-dasharray&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;1,200;90,200;1,200&#39;%3E%3C/animate%3E%3Canimate attributeName=&#39;stroke-dashoffset&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;-35px;-125px&#39;%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);--icon-size: 48px;display: inline-block;width: var(--icon-size);height: var(--icon-size);background-color: currentcolor;-webkit-mask-image: var(--loading-icon);mask-image: var(--loading-icon)"></span></div></div><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">默认页脚</div><div class="vp-copyright">Copyright © 2025 钱鹏展 </div></footer></div><!--]--><!--]--><!--[--><!----><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/blog/assets/app-BxRTHQDl.js" defer></script>
  </body>
</html>
