import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,a as s,f as p,d as n,w as l,r,o as d,b as t}from"./app-BxRTHQDl.js";const k={},o={class:"table-of-contents"};function g(u,i){const a=r("router-link");return d(),h("div",null,[i[6]||(i[6]=s("h2",{id:"什么是全双工、半双工",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#什么是全双工、半双工"},[s("span",null,"什么是全双工、半双工?")])],-1)),s("nav",o,[s("ul",null,[s("li",null,[n(a,{to:"#什么是全双工、半双工"},{default:l(()=>i[0]||(i[0]=[t("什么是全双工、半双工?")])),_:1,__:[0]}),s("ul",null,[s("li",null,[n(a,{to:"#_1-‌-全双工通信-full-duplex"},{default:l(()=>i[1]||(i[1]=[t("1. ‌ 全双工通信(Full Duplex)")])),_:1,__:[1]})]),s("li",null,[n(a,{to:"#_2-‌-半双工通信-half-duplex"},{default:l(()=>i[2]||(i[2]=[t("2. ‌ 半双工通信(Half Duplex)")])),_:1,__:[2]})]),s("li",null,[n(a,{to:"#_3-‌-单工通信-simplex"},{default:l(()=>i[3]||(i[3]=[t("3. ‌ 单工通信(Simplex)")])),_:1,__:[3]})]),s("li",null,[n(a,{to:"#java网络编程中的体现"},{default:l(()=>i[4]||(i[4]=[t("Java网络编程中的体现：")])),_:1,__:[4]})]),s("li",null,[n(a,{to:"#关键区别图示"},{default:l(()=>i[5]||(i[5]=[t("关键区别图示：")])),_:1,__:[5]})])])])])]),i[7]||(i[7]=p(`<blockquote><p>说在前面的话，本文为日常开发过程中遇到的一些问题，整理记录成模块，方面后续遇到直接查询解决。</p></blockquote><p>在计算机网络中，&quot;全双工&quot;和&quot;半双工&quot;描述了数据流动的方式：</p><h3 id="_1-‌-全双工通信-full-duplex" tabindex="-1"><a class="header-anchor" href="#_1-‌-全双工通信-full-duplex"><span>1. ‌ 全双工通信(Full Duplex)</span></a></h3><ul><li>‌<strong>定义</strong>‌：通信双方可以‌<strong>同时</strong>‌发送和接收数据</li><li>‌特点： <ul><li>双向数据传输能力</li><li>发送和接收操作并行进行</li><li>需要独立的发送和接收信道</li></ul></li><li>‌<strong>类比</strong>‌：电话通话（双方能同时说话和听对方说话）</li><li>‌<strong>Java示例</strong>‌：</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 服务端响应客户端后继续监听新消息</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">client</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">write</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">ByteBuffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">wrap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">response</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getBytes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 发送响应</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 此时服务端可继续处理其他通道的请求</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-‌-半双工通信-half-duplex" tabindex="-1"><a class="header-anchor" href="#_2-‌-半双工通信-half-duplex"><span>2. ‌ 半双工通信(Half Duplex)</span></a></h3><ul><li>‌<strong>定义</strong>‌：通信双方可以双向传输数据，但‌<strong>不能同时</strong>‌进行</li><li>‌特点： <ul><li>交替进行发送和接收</li><li>某一时刻只能单向传输</li><li>需要通信协议协调传输方向</li></ul></li><li>‌<strong>类比</strong>‌：对讲机（按着说话键时不能听，松开才能听）</li><li>‌<strong>Java示例</strong>‌：</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 服务端必须等待客户端发送完成才能响应</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">((input </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">readLine</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(input);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 发送（此时不能接收）</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;等待回复...&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    response </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">readLine</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 接收（此时不能发送）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-‌-单工通信-simplex" tabindex="-1"><a class="header-anchor" href="#_3-‌-单工通信-simplex"><span>3. ‌ 单工通信(Simplex)</span></a></h3><ul><li>‌<strong>定义</strong>‌：数据只能‌<strong>单向传输</strong>‌</li><li>‌特点‌： <ul><li>固定方向的通信</li><li>一方只能发送，另一方只能接收</li></ul></li><li>‌<strong>类比</strong>‌：广播电台（电台只能发送，收音机只能接收）</li></ul><h3 id="java网络编程中的体现" tabindex="-1"><a class="header-anchor" href="#java网络编程中的体现"><span>Java网络编程中的体现：</span></a></h3><table><thead><tr><th>特性</th><th>BIO示例</th><th>NIO示例</th></tr></thead><tbody><tr><td>‌<strong>连接类型</strong>‌</td><td>全双工（TCP特性）</td><td>全双工（TCP特性）</td></tr><tr><td>‌<strong>实现方式</strong>‌</td><td>半双工使用方式</td><td>真正的全双工实现</td></tr><tr><td>‌<strong>原因</strong>‌</td><td>单线程顺序处理</td><td>多路复用支持并发读写</td></tr></tbody></table><h3 id="关键区别图示" tabindex="-1"><a class="header-anchor" href="#关键区别图示"><span>关键区别图示：</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>全双工：</span></span>
<span class="line"><span>  客户端 →→ 数据 →→ 服务端</span></span>
<span class="line"><span>  客户端 ←← 数据 ←← 服务端</span></span>
<span class="line"><span>  (双向同时传输)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>半双工：</span></span>
<span class="line"><span>  客户端 →→ 数据 →→ 服务端</span></span>
<span class="line"><span>  (传输完成后)</span></span>
<span class="line"><span>  客户端 ←← 数据 ←← 服务端</span></span>
<span class="line"><span>  (交替传输)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实际Java网络编程中：</p><ol><li>‌<strong>TCP协议本身是全双工的</strong>‌（底层支持双向同时传输）</li><li>‌<strong>BIO模型常表现为半双工</strong>‌：因为单线程顺序处理请求/响应</li><li>‌<strong>NIO/AIO可实现真正全双工</strong>‌：通过Selector多路复用，读写操作互不阻塞</li><li>‌<strong>WebSocket是全双工典型</strong>‌：建立连接后双方可随时互发消息</li></ol><blockquote><p>建议：需要实时双向通信的场景（如聊天室、游戏）应使用NIO+WebSocket实现全双工，而简单的请求-响应场景可以使用半双工模式。</p></blockquote>`,17))])}const m=e(k,[["render",g]]),y=JSON.parse('{"path":"/md/question/net/question_net_001.html","title":"","lang":"zh-CN","frontmatter":{"description":"什么是全双工、半双工? 说在前面的话，本文为日常开发过程中遇到的一些问题，整理记录成模块，方面后续遇到直接查询解决。 在计算机网络中，\\"全双工\\"和\\"半双工\\"描述了数据流动的方式： 1. ‌ 全双工通信(Full Duplex) ‌定义‌：通信双方可以‌同时‌发送和接收数据 ‌特点： 双向数据传输能力 发送和接收操作并行进行 需要独立的发送和接收信道 ‌...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-04T06:08:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钱鹏展\\",\\"url\\":\\"https://github.com/pengzhanqian\\"}]}"],["meta",{"property":"og:url","content":"https://pengzhanqian.github.io/blog/md/question/net/question_net_001.html"}],["meta",{"property":"og:site_name","content":"学习笔记"}],["meta",{"property":"og:description","content":"什么是全双工、半双工? 说在前面的话，本文为日常开发过程中遇到的一些问题，整理记录成模块，方面后续遇到直接查询解决。 在计算机网络中，\\"全双工\\"和\\"半双工\\"描述了数据流动的方式： 1. ‌ 全双工通信(Full Duplex) ‌定义‌：通信双方可以‌同时‌发送和接收数据 ‌特点： 双向数据传输能力 发送和接收操作并行进行 需要独立的发送和接收信道 ‌..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-04T06:08:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-04T06:08:40.000Z"}]]},"git":{"createdTime":1751549516000,"updatedTime":1751609320000,"contributors":[{"name":"钱鹏展","username":"","email":"873373549@qq.com","commits":2}]},"readingTime":{"minutes":2.25,"words":674},"filePathRelative":"md/question/net/question_net_001.md","autoDesc":true}');export{m as comp,y as data};
